---
id: tictactoe
title: A Game of Tic-Tac-Toe in Leo
---
[general tags]: # (example, tictactoe, program, struct, conditional)

**[Source Code](https://github.com/ProvableHQ/leo-examples/tree/main/tictactoe)**

## 概要

Leo で三目並べ（Tic-Tac-Toe）の基本的なゲームをプレイできます。おなじみの盤面は次のようなものです。

⭕ ❕ ⭕ ❕ ❌

➖ ➕ ➖ ➕ ➖

⭕ ❕ ⁣❌ ❕ ⭕

➖ ➕ ➖ ➕ ➖

❌ ❕ ❌ ❕ ⭕

## 状態の表現方法
Leo では `struct` キーワードを使って複合データ型を定義できます。ゲームボードは `Row` を 3 つ含む `Board` という構造体で表現します。配列で表現する方法も考えられますが、現状の Leo では配列が未サポートのため構造体を利用しています。

## 登場する言語機能
- `struct` 宣言
- 条件分岐
- 早期リターン（`return` キーワードで途中終了が可能）

## 実行方法

[Leo のインストール手順](https://docs.leo-lang.org/getting_started/installation) に従って環境を整えてください。

この三目並べプログラムは次の bash スクリプトで実行できます。ローカル環境で実行すると、盤面の生成からプレイ進行までを Leo プログラムで確認できます。

```bash
cd tictactoe
./run.sh
```

## チュートリアルの流れ

* [ステップ 0: 新しいボードを作成](#step0)
* [ステップ 1: プレイヤー 1 の初手](#step1)
* [ステップ 2: プレイヤー 2 の 2 手目](#step2)
* [ステップ 3: プレイヤー 1 の 3 手目](#step3)
* [ステップ 4: 以下同様に進行](#step4)

## <a id="step0"></a> 新しいボードを作成

まずボードを生成し、その後プレイヤーが交互に `make_move` トランジション関数を実行していきます。

関数への入力は、プレイヤー番号・行位置・列位置・直前のボード状態です。

出力として、新しいボード状態と勝敗評価が返されます。評価が `0u8` の場合は、盤面が埋まって引き分けになるか、ゲームがまだ続いていることを意味します。

```bash
leo run new
```
## <a id="step1"></a> プレイヤー 1 の手番

プレイヤー 1 が初手を打ちます。

```bash
leo run make_move 1u8 1u8 1u8 "{ r1: { c1: 0u8, c2: 0u8, c3: 0u8 }, r2: { c1: 0u8, c2: 0u8, c3: 0u8 }, r3: { c1: 0u8, c2: 0u8, c3: 0u8 } }"
```

## <a id="step2"></a> プレイヤー 2 の手番

プレイヤー 2 が 2 手目を打ちます。

```bash
leo run make_move 2u8 2u8 2u8 "{ r1: { c1: 1u8, c2: 0u8, c3: 0u8 }, r2: { c1: 0u8, c2: 0u8, c3: 0u8 }, r3: { c1: 0u8, c2: 0u8, c3: 0u8 } }"
```

## <a id="step3"></a> プレイヤー 1 の手番

プレイヤー 1 が 3 手目を打ちます。

```bash
leo run make_move 1u8 3u8 1u8 "{ r1: { c1: 1u8, c2: 0u8, c3: 0u8 }, r2: { c1: 0u8, c2: 2u8, c3: 0u8 }, r3: { c1: 0u8, c2: 0u8, c3: 0u8 } }"
```

## <a id="step4"></a> 以降の手順

スクリプトの手順を最後まで追うと、出力が `0u64` となり引き分けになる様子が確認できます。

このサンプルではレコードを使用していません。Leo の言語機能を紹介することが主目的であり、実際のゼロ知識ゲームの完全な実装例ではないためです。より本格的な実装では、プレイヤー間でレコードを受け渡してゲーム状態を安全に維持する必要があります。
